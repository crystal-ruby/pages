%section#how
  %h2 That was what
  %br
  %h4 next
  %br
  %h1 How
  %p.fragment With rails analogy

%section#size
  %h2 Size
  %p compared to rails
  %h3 active_record 1.0
  %h3.fragment 1 / 3 active_record (rails 1.0)
  %h3.fragment 1 / 10 rails

%section#app
  %h2 Rails app
  %p many views
  %br
  %h2.fragment RubyX
  %p.fragment many methods
  %br
  %h4.fragment method = view

%section#controller
  %h3 controller renders view
  %br
  %h3.fragment compiler compiles methods
  %br
  %h4.fragment controller = compiler

%section#http
  %h3 rack handles http
  %br
  %h3.fragment assembler binary creation
  %br
  %h4.fragment lower levels don't matter to most

%section#layers
  %h3 request processed by layers
  %br
  %h3.fragment Compiler processes in layers
  %br
  %h4.fragment same same, but different :-)

%section
  %section#compiler_layers
    %h2 Compiler layers
    %p Ruby source (parser gem)
    %p.fragment Simple Object Language
    %p.fragment SlotMachine
    %p.fragment Risc abstraction
    %p.fragment Target (arm)
    %p.fragment Elf / binary

  %section#sol
    %h2 Sol, Simple Object language
    %p simple, ruby without the fluff ( splats / unless ..)
    %p object model like ruby
    %p Statements + Expression
    %p nothing implicit

  %section#machines
    %h2 Language vs Machine
    %p next level is (abtract) machine
    %p.fragment statement tree vs instruction list
    %p.fragment variables vs memory
    %p.fragment control structures vs jumps
    %p.fragment abstract vs basic

  %section#mom
    %section#mom1
      %h2 SlotMachine
      %p 16 instructions
      %p.fragment Works only on memory
      %p.fragment higher level than next
      %p.fragment ease transition to next level
      %p.fragment 1 Sol â†’ 2-8 slot

    %section#mom2
      %h2 SlotMachine instructions
      %p simple call , argument transfer , return sequence
      %p.fragment dynamic call , method resolve
      %p.fragment checks with implicit jumps
      %p.fragment ruby truth check , identity check
      %p.fragment yield . . .
  %section
    %section#risc1
      %h2 Risc abstraction
      %p arm without the fluff
      %p.fragment arm like registers
      %p.fragment 20 instructions
      %p.fragment extensible (for builtin + more)
      %p.fragment last virtual layer
      %p.fragment interpreter + visual debugger

    %section#risc2
      %h2 Risc instructions
      %p mem/reg + reg/reg
      %p.fragment arithmetic operators
      %p.fragment tests on operation result
      %p.fragment jump , call , return
      %p.fragment syscall

%section#code
  %h2 Code generation
  %br
  %br
  %h2.fragment Object generation

%section#model
  %h2 Object Model
  %p Everything is Object
  %p.fragment Fixed sizes
  %p.fragment opaque data, ruby has no access
  %p.fragment slot instructions to process data

%section#types
  %h2 Object has Type
  %p.fragment Types are immutable
  %p.fragment Types store callable methods
  %p.fragment maps names to indexes
  %p.fragment does not define types recursively
  %p.fragment type reference may change

%section#classes
  %h2 Type implements Class
  %p Class has instance Type
  %p.fragment new object has instance type
  %p.fragment instance type may change
  %p.fragment many types implement one class
  %p.fragment class stores method definition

%section#dynamics
  %h3 Types are static
  %h3 Ruby is dynamic
  %h3.fragment.fade-out ?
  %p.fragment objects type reference may change
  %p.fragment class instance type may change

%section#parfait
  %h2 Basic Objects: Parfait
  %p minimal runtime for compiling
  %p.fragment Basic oo: Class , Type , Method , Code
  %p.fragment Utils: String, Integer , Array , Hash
  %p.fragment  also, additional builtin methods

%section#project
  %h2 Project
  %p 5 years
  %p 3k commits , 1600 tests
  %p multi arch ready, arm working
  %p basic executables (mini rt)
  %p stable architecture
